## 栈与调用惯例

**栈保存了一个函数调用所需要的维护信息**，这常常被称为堆栈帧或活动记录。堆栈帧一般包括如下几个方面内容：
- 函数的返回地址；
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量；
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

esp寄存器始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部。而相对的，ebp寄存器指向了函数活动记录的的一个固定位置，ebp寄存器又被称为帧指针。

调用方：
- 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递；
- 把当前指令的下一条指令的地址压入栈中；
- 跳转到函数体执行；

**esp: 指向已经存储数据的slot顶部**

其中第二条和第三条由指令call一起执行。跳转到函数体之后即开始执行函数：
- push ebp: 把ebp压入栈中(old ebp)； 
    - move (ebp), esp; 
    - subl 4, esp;
- mov ebp, esp: ebp = esp(这是ebp指向栈顶)；
- [option] sub esp, XXX: 在栈上分配XXX字节的临时空间；
- [option] push XXX: 如有必要，保存名为XXX的寄存器(可重复多个)；

**把ebp压入栈中，是为了在函数返回的时候便于恢复以前的ebp值。而之所以可能要保存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调用开始时将这些寄存器的值压入栈中，在结束后再取出。**

- [option] pop XXX: 如有必要，恢复保存过的寄存器(可重复多个)；
- move esp, ebp: 恢复ESP同时回收局部变量空间；
- pop ebp: 从栈中恢复保存的ebp值；
- ret: 从栈中取得返回地址，并跳转到该位置；

**出栈方：表示由谁将esp恢复到当前函数栈或上一个函数栈的栈底，例如func(int, int, int)函数，c++以及c语言在ｇcc或g++指定-m32选项时,由函数调用方进行 add 12, esp**

|调用惯例|出栈房|参数传递|名字修饰|
|--|--|--|--|
|cdecl|函数调用方|从右至左的顺序压参数入栈|下划线+函数名|
|stdcall|函数本身|从右至左的顺序压参数入栈|下划线+函数名+@参数的字节数,如函数int func(int a, double b)的修饰名是_func@12|


## 函数返回值传递
```
typedef struct big_thing {
    char buf[128];
} big_thing;

big_thing return_test() {
    bit_thing b;
    b.buf[0] = 0;
    return b;
}

int main()
{
    big_thing n = return_test();
}
```

以上函数的返回值长度过长，无法使用寄存器完成值传递，所以编译器会在栈上产生一个临时对象，将临时对象的地址作为return_test的函数参数,将n的地址作为返回地址;

**为什么需要临时对象，直接拷贝给n不行吗?**

因为"="是一个赋值操作，所以必须有东西作为右值，于是需要临时对象!

步骤：
- 首先main函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp；
- 将temp对象的地址作为隐藏参数传递给return_test函数；
- return_test函数将数据拷贝给temp对象，并将temp对象的地址用eax传出；
- return_test返回之后，main函数将eax指向的temp对象的内容拷贝给n。

在c++中，ROV(return value optimization)技术可以减少额外的开销，但是仅限于如下情况:
```
cpp_obj return_test() {
    ...
    return cpp_obj();
}
```